"use strict";
// -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const error_hints_1 = __importDefault(require("../../browser/connection/error-hints"));
const DOCUMENTATION_LINKS = {
    TEST_SOURCE_PARAMETER: 'https://testcafe.io/documentation/402639/reference/command-line-interface#file-pathglob-pattern',
    FILTER_SETTINGS: 'https://testcafe.io/documentation/402638/reference/configuration-file#filter',
    HEADLESS_MODE: 'https://testcafe.io/documentation/402828/guides/concepts/browsers#test-in-headless-mode',
};
exports.default = {
    [types_1.RUNTIME_ERRORS.cannotCreateMultipleLiveModeRunners]: 'Cannot launch multiple live mode instances of the TestCafe test runner.',
    [types_1.RUNTIME_ERRORS.cannotRunLiveModeRunnerMultipleTimes]: 'Cannot launch the same live mode instance of the TestCafe test runner multiple times.',
    [types_1.RUNTIME_ERRORS.browserDisconnected]: 'The {userAgent} browser disconnected. If you did not close the browser yourself, browser performance or network issues may be at fault.',
    [types_1.RUNTIME_ERRORS.cannotRunAgainstDisconnectedBrowsers]: 'The following browsers disconnected: {userAgents}. Cannot run further tests.',
    [types_1.RUNTIME_ERRORS.testRunRequestInDisconnectedBrowser]: '"{browser}" disconnected during test execution.',
    [types_1.RUNTIME_ERRORS.cannotEstablishBrowserConnection]: 'Cannot establish one or more browser connections.',
    [types_1.RUNTIME_ERRORS.cannotFindBrowser]: 'Cannot find the browser. "{browser}" is neither a known browser alias, nor a path to an executable file.',
    [types_1.RUNTIME_ERRORS.browserProviderNotFound]: 'Cannot find the "{providerName}" browser provider.',
    [types_1.RUNTIME_ERRORS.browserNotSet]: 'You have not specified a browser.',
    [types_1.RUNTIME_ERRORS.testFilesNotFound]: 'Could not find test files at the following location: "{cwd}".\n' +
        'Check patterns for errors:\n\n' +
        '{sourceList}\n\n' +
        'or launch TestCafe from a different directory.\n' +
        `For more information on how to specify test locations, see ${DOCUMENTATION_LINKS.TEST_SOURCE_PARAMETER}.`,
    [types_1.RUNTIME_ERRORS.noTestsToRun]: "Source files do not contain valid 'fixture' and 'test' declarations.",
    [types_1.RUNTIME_ERRORS.noTestsToRunDueFiltering]: 'No tests match your filter.\n' +
        `See ${DOCUMENTATION_LINKS.FILTER_SETTINGS}.`,
    [types_1.RUNTIME_ERRORS.cannotFindReporterForAlias]: 'The "{name}" reporter does not exist. Check the reporter parameter for errors.',
    [types_1.RUNTIME_ERRORS.multipleSameStreamReporters]: 'Reporters cannot share output streams. The following reporters interfere with one another: "{reporters}".',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidRegExp]: 'The "{optionName}" option does not contain a valid regular expression.',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidKeyValue]: 'The "{optionName}" option does not contain a valid key-value pair.',
    [types_1.RUNTIME_ERRORS.invalidQuarantineOption]: 'The "{optionName}" option does not exist. Specify "attemptLimit" and "successThreshold" to configure quarantine mode.',
    [types_1.RUNTIME_ERRORS.invalidQuarantineParametersRatio]: 'The value of "attemptLimit" ({attemptLimit}) should be greater then the value of "successThreshold" ({successThreshold}).',
    [types_1.RUNTIME_ERRORS.invalidAttemptLimitValue]: 'The "{attemptLimit}" parameter only accepts values of {MIN_ATTEMPT_LIMIT} and up.',
    [types_1.RUNTIME_ERRORS.invalidSuccessThresholdValue]: 'The "{successThreshold}" parameter only accepts values of {MIN_SUCCESS_THRESHOLD} and up.',
    [types_1.RUNTIME_ERRORS.invalidSpeedValue]: 'Speed should be a number between 0.01 and 1.',
    [types_1.RUNTIME_ERRORS.invalidConcurrencyFactor]: 'The concurrency factor should be an integer greater than or equal to 1.',
    [types_1.RUNTIME_ERRORS.cannotDivideRemotesCountByConcurrency]: 'The number of remote browsers should be divisible by the concurrency factor.',
    [types_1.RUNTIME_ERRORS.cannotSetConcurrencyWithCDPPort]: 'The value of the "concurrency" option includes the CDP port.',
    [types_1.RUNTIME_ERRORS.portsOptionRequiresTwoNumbers]: 'The "--ports" argument accepts two values at a time.',
    [types_1.RUNTIME_ERRORS.portIsNotFree]: 'Port {portNum} is occupied by another process.',
    [types_1.RUNTIME_ERRORS.invalidHostname]: 'Cannot resolve hostname "{hostname}".',
    [types_1.RUNTIME_ERRORS.cannotFindSpecifiedTestSource]: 'Cannot find a test file at "{path}".',
    [types_1.RUNTIME_ERRORS.clientFunctionCodeIsNotAFunction]: 'Cannot initialize a ClientFunction because {#instantiationCallsiteName} is {type}, and not a function.',
    [types_1.RUNTIME_ERRORS.selectorInitializedWithWrongType]: 'Cannot initialize a Selector because {#instantiationCallsiteName} is {type}, and not one of the following: a CSS selector string, a Selector object, a node snapshot, a function, or a Promise returned by a Selector.',
    [types_1.RUNTIME_ERRORS.clientFunctionCannotResolveTestRun]: "{#instantiationCallsiteName} cannot implicitly resolve the test run in context of which it should be executed. If you need to call {#instantiationCallsiteName} from the Node.js API callback, pass the test controller manually via {#instantiationCallsiteName}'s `.with({ boundTestRun: t })` method first. Note that you cannot execute {#instantiationCallsiteName} outside the test code.",
    [types_1.RUNTIME_ERRORS.requestCannotResolveTestRun]: "'request' cannot implicitly resolve the test run in context of which it should be executed. Note that you cannot execute 'request' in the experimental debug mode.",
    [types_1.RUNTIME_ERRORS.regeneratorInClientFunctionCode]: `{#instantiationCallsiteName} code, arguments or dependencies cannot contain generators or "async/await" syntax (use Promises instead).`,
    [types_1.RUNTIME_ERRORS.invalidClientFunctionTestRunBinding]: 'Cannot resolve the "boundTestRun" option because its value is not a test controller.',
    [types_1.RUNTIME_ERRORS.invalidValueType]: '{smthg} ({actual}) is not of expected type ({type}).',
    [types_1.RUNTIME_ERRORS.unsupportedUrlProtocol]: 'Invalid {what}: "{url}". TestCafe cannot execute the test because the {what} includes the {protocol} protocol. TestCafe supports the following protocols: http://, https:// and file://.',
    [types_1.RUNTIME_ERRORS.testControllerProxyCannotResolveTestRun]: `Cannot implicitly resolve the test run in the context of which the test controller action should be executed. Use test function's 't' argument instead.`,
    [types_1.RUNTIME_ERRORS.timeLimitedPromiseTimeoutExpired]: 'A Promise timed out.',
    [types_1.RUNTIME_ERRORS.cannotSetVideoOptionsWithoutBaseVideoPathSpecified]: 'You cannot manage advanced video parameters when the video recording capability is off. Specify the root storage folder for video content to enable video recording.',
    [types_1.RUNTIME_ERRORS.multipleAPIMethodCallForbidden]: 'You cannot call the "{methodName}" method more than once. Specify an array of parameters instead.',
    [types_1.RUNTIME_ERRORS.invalidReporterOutput]: "Specify a file name or a writable stream as the reporter's output target.",
    [types_1.RUNTIME_ERRORS.cannotReadSSLCertFile]: 'Unable to read the file referenced by the "{option}" ssl option ("{path}"). Error details:\n' +
        '\n' +
        '{err}',
    [types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError]: 'Cannot prepare tests due to the following error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.cannotParseRawFile]: 'Cannot parse a raw test file at "{path}" due to the following error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.testedAppFailedWithError]: 'The web application failed with the following error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.unableToOpenBrowser]: 'Unable to open the "{alias}" browser due to the following error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.requestHookConfigureAPIError]: 'Attempt to configure a request hook resulted in the following error:\n' +
        '\n' +
        '{requestHookName}: {errMsg}',
    [types_1.RUNTIME_ERRORS.forbiddenCharatersInScreenshotPath]: 'There are forbidden characters in the "{screenshotPath}" {screenshotPathType}:\n' +
        ' {forbiddenCharsDescription}',
    [types_1.RUNTIME_ERRORS.cannotFindFFMPEG]: 'TestCafe cannot record videos because it cannot locate the FFmpeg executable. Try one of the following solutions:\n' +
        '\n' +
        '* add the path of the FFmpeg installation directory to the PATH environment variable,\n' +
        '* specify the path of the FFmpeg executable in the FFMPEG_PATH environment variable or the ffmpegPath option,\n' +
        '* install the @ffmpeg-installer/ffmpeg npm package.',
    [types_1.RUNTIME_ERRORS.cannotFindTypescriptConfigurationFile]: '"{filePath}" is not a valid TypeScript configuration file.',
    [types_1.RUNTIME_ERRORS.clientScriptInitializerIsNotSpecified]: 'Initialize your client script with one of the following: a JavaScript script, a JavaScript file path, or the name of a JavaScript module.',
    [types_1.RUNTIME_ERRORS.clientScriptBasePathIsNotSpecified]: 'Specify the base path for the client script file.',
    [types_1.RUNTIME_ERRORS.clientScriptInitializerMultipleContentSources]: 'Client scripts can only have one initializer: JavaScript code, a JavaScript file path, or the name of a JavaScript module.',
    [types_1.RUNTIME_ERRORS.cannotLoadClientScriptFromPath]: 'Cannot load a client script from {path}.\n{errorMessage}',
    [types_1.RUNTIME_ERRORS.clientScriptModuleEntryPointPathCalculationError]: 'A client script tried to load a JavaScript module that TestCafe cannot locate:\n\n{errorMessage}.',
    [types_1.RUNTIME_ERRORS.methodIsNotAvailableForAnIPCHost]: 'This method cannot be called on a service host.',
    [types_1.RUNTIME_ERRORS.tooLargeIPCPayload]: 'The specified payload is too large to form an IPC packet.',
    [types_1.RUNTIME_ERRORS.malformedIPCMessage]: 'Cannot process a malformed IPC message.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCHeadPacket]: 'Cannot create an IPC message due to an unexpected IPC head packet.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCBodyPacket]: 'Cannot create an IPC message due to an unexpected IPC body packet.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCTailPacket]: 'Cannot create an IPC message due to an unexpected IPC tail packet.',
    [types_1.RUNTIME_ERRORS.cannotRunLocalNonHeadlessBrowserWithoutDisplay]: 'Your Linux version does not have a graphic subsystem to run {browserAlias} with a GUI. ' +
        'You can launch the browser in headless mode. ' +
        'If you use a portable browser executable, ' +
        "specify the browser alias before the path instead of the 'path' prefix. " +
        `For more information, see ${DOCUMENTATION_LINKS.HEADLESS_MODE}`,
    [types_1.RUNTIME_ERRORS.uncaughtErrorInReporter]: 'The "{methodName}" method of the "{reporterName}" reporter produced an uncaught error. Error details:\n{originalError}',
    [types_1.RUNTIME_ERRORS.roleInitializedWithRelativeUrl]: 'You cannot specify relative login page URLs in the Role constructor. Use an absolute URL.',
    [types_1.RUNTIME_ERRORS.typeScriptCompilerLoadingError]: 'Cannot load the TypeScript compiler.\n{originErrorMessage}.',
    [types_1.RUNTIME_ERRORS.cannotCustomizeSpecifiedCompilers]: 'You cannot specify options for the {noncustomizableCompilerList} compiler{suffix}.',
    [types_1.RUNTIME_ERRORS.cannotEnableRetryTestPagesOption]: 'Cannot enable the \'retryTestPages\' option. Apply one of the following two solutions:\n' +
        '-- set \'localhost\' as the value of the \'hostname\' option\n' +
        '-- run TestCafe over HTTPS\n',
    [types_1.RUNTIME_ERRORS.browserConnectionError]: '{originErrorMessage}\n{numOfNotOpenedConnection} of {numOfAllConnections} browser connections have not been established:\n{listOfNotOpenedConnections}\n\nHints:\n{listOfHints}',
    [error_hints_1.default.TooHighConcurrencyFactor]: 'The host machine may not be powerful enough to handle the specified concurrency factor ({concurrencyFactor}). ' +
        'Try to decrease the concurrency factor or allocate more computing resources to the host machine.',
    [error_hints_1.default.UseBrowserInitOption]: 'Increase the value of the "browserInitTimeout" option if it is too low (currently: {browserInitTimeoutMsg}). This option determines how long TestCafe waits for browsers to be ready.',
    [error_hints_1.default.RestErrorCauses]: 'The error can also be caused by network issues or remote device failure. Make sure that your network connection is stable and you can reach the remote device.',
    [types_1.RUNTIME_ERRORS.cannotFindTestcafeConfigurationFile]: 'Cannot locate a TestCafe configuration file at {filePath}. Either the file does not exist, or the path is invalid.',
    [types_1.RUNTIME_ERRORS.dashboardTokenInJSON]: 'Insecure token declaration: cannot declare a Dashboard token in a JSON configuration file. Use a JavaScript configuration file, or declare a Dashboard token with one of the following: the CLI, the Test Runner API, the TESTCAFE_DASHBOARD_TOKEN environment variable.',
    [types_1.RUNTIME_ERRORS.relativeBaseUrl]: 'The value of the baseUrl argument cannot be relative: "{baseUrl}"',
    [types_1.RUNTIME_ERRORS.requestUrlInvalidValueError]: 'Requested url isn\'t valid ({actualValue}).',
    [types_1.RUNTIME_ERRORS.requestRuntimeError]: 'Requested was interrupted with error:\n{message}',
};
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Vycm9ycy9ydW50aW1lL3RlbXBsYXRlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSwrQ0FBK0M7QUFDL0MsZ0VBQWdFOzs7OztBQUVoRSxvQ0FBMEM7QUFDMUMsdUZBQThFO0FBRTlFLE1BQU0sbUJBQW1CLEdBQUc7SUFDeEIscUJBQXFCLEVBQUUsaUdBQWlHO0lBQ3hILGVBQWUsRUFBUSw4RUFBOEU7SUFDckcsYUFBYSxFQUFVLHlGQUF5RjtDQUNuSCxDQUFDO0FBRUYsa0JBQWU7SUFDWCxDQUFDLHNCQUFjLENBQUMsbUNBQW1DLENBQUMsRUFBRyx5RUFBeUU7SUFDaEksQ0FBQyxzQkFBYyxDQUFDLG9DQUFvQyxDQUFDLEVBQUUsdUZBQXVGO0lBQzlJLENBQUMsc0JBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFtQix5SUFBeUk7SUFDaE0sQ0FBQyxzQkFBYyxDQUFDLG9DQUFvQyxDQUFDLEVBQUUsOEVBQThFO0lBQ3JJLENBQUMsc0JBQWMsQ0FBQyxtQ0FBbUMsQ0FBQyxFQUFHLGlEQUFpRDtJQUN4RyxDQUFDLHNCQUFjLENBQUMsZ0NBQWdDLENBQUMsRUFBTSxtREFBbUQ7SUFDMUcsQ0FBQyxzQkFBYyxDQUFDLGlCQUFpQixDQUFDLEVBQXFCLDBHQUEwRztJQUNqSyxDQUFDLHNCQUFjLENBQUMsdUJBQXVCLENBQUMsRUFBZSxvREFBb0Q7SUFDM0csQ0FBQyxzQkFBYyxDQUFDLGFBQWEsQ0FBQyxFQUF5QixtQ0FBbUM7SUFDMUYsQ0FBQyxzQkFBYyxDQUFDLGlCQUFpQixDQUFDLEVBQXFCLGlFQUFpRTtRQUNqRSxnQ0FBZ0M7UUFDaEMsa0JBQWtCO1FBQ2xCLGtEQUFrRDtRQUNsRCw4REFBOEQsbUJBQW1CLENBQUMscUJBQXFCLEdBQUc7SUFFakssQ0FBQyxzQkFBYyxDQUFDLFlBQVksQ0FBQyxFQUFF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Q0FBQyx1QkFBdUIsQ0FBQyxFQUFZLHdIQUF3SDtJQUM1SyxDQUFDLHNCQUFjLENBQUMsOEJBQThCLENBQUMsRUFBSywyRkFBMkY7SUFDL0ksQ0FBQyxzQkFBYyxDQUFDLDhCQUE4QixDQUFDLEVBQUssNkRBQTZEO0lBQ2pILENBQUMsc0JBQWMsQ0FBQyxpQ0FBaUMsQ0FBQyxFQUFFLG9GQUFvRjtJQUV4SSxDQUFDLHNCQUFjLENBQUMsZ0NBQWdDLENBQUMsRUFDN0MsMEZBQTBGO1FBQzFGLGdFQUFnRTtRQUNoRSw4QkFBOEI7SUFFbEMsQ0FBQyxzQkFBYyxDQUFDLHNCQUFzQixDQUFDLEVBQWdCLGlMQUFpTDtJQUN4TyxDQUFDLHFCQUEwQixDQUFDLHdCQUF3QixDQUFDLEVBQUUsZ0hBQWdIO1FBQ2hILGtHQUFrRztJQUN6SixDQUFDLHFCQUEwQixDQUFDLG9CQUFvQixDQUFDLEVBQUssdUxBQXVMO0lBQzdPLENBQUMscUJBQTBCLENBQUMsZUFBZSxDQUFDLEVBQVUsZ0tBQWdLO0lBQ3ROLENBQUMsc0JBQWMsQ0FBQyxtQ0FBbUMsQ0FBQyxFQUFFLG9IQUFvSDtJQUMxSyxDQUFDLHNCQUFjLENBQUMsb0JBQW9CLENBQUMsRUFBaUIsMFFBQTBRO0lBQ2hVLENBQUMsc0JBQWMsQ0FBQyxlQUFlLENBQUMsRUFBc0IsbUVBQW1FO0lBQ3pILENBQUMsc0JBQWMsQ0FBQywyQkFBMkIsQ0FBQyxFQUFVLDZDQUE2QztJQUNuRyxDQUFDLHNCQUFjLENBQUMsbUJBQW1CLENBQUMsRUFBa0Isa0RBQWtEO0NBQzNHLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBXQVJOSU5HOiB0aGlzIGZpbGUgaXMgdXNlZCBieSBib3RoIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIuXG4vLyBEbyBub3QgdXNlIGFueSBicm93c2VyIG9yIG5vZGUtc3BlY2lmaWMgQVBJIVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBCcm93c2VyQ29ubmVjdGlvbkVycm9ySGludCBmcm9tICcuLi8uLi9icm93c2VyL2Nvbm5lY3Rpb24vZXJyb3ItaGludHMnO1xuXG5jb25zdCBET0NVTUVOVEFUSU9OX0xJTktTID0ge1xuICAgIFRFU1RfU09VUkNFX1BBUkFNRVRFUjogJ2h0dHBzOi8vdGVzdGNhZmUuaW8vZG9jdW1lbnRhdGlvbi80MDI2MzkvcmVmZXJlbmNlL2NvbW1hbmQtbGluZS1pbnRlcmZhY2UjZmlsZS1wYXRoZ2xvYi1wYXR0ZXJuJyxcbiAgICBGSUxURVJfU0VUVElOR1M6ICAgICAgICdodHRwczovL3Rlc3RjYWZlLmlvL2RvY3VtZW50YXRpb24vNDAyNjM4L3JlZmVyZW5jZS9jb25maWd1cmF0aW9uLWZpbGUjZmlsdGVyJyxcbiAgICBIRUFETEVTU19NT0RFOiAgICAgICAgICdodHRwczovL3Rlc3RjYWZlLmlvL2RvY3VtZW50YXRpb24vNDAyODI4L2d1aWRlcy9jb25jZXB0cy9icm93c2VycyN0ZXN0LWluLWhlYWRsZXNzLW1vZGUnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RDcmVhdGVNdWx0aXBsZUxpdmVNb2RlUnVubmVyc106ICAnQ2Fubm90IGxhdW5jaCBtdWx0aXBsZSBsaXZlIG1vZGUgaW5zdGFuY2VzIG9mIHRoZSBUZXN0Q2FmZSB0ZXN0IHJ1bm5lci4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RSdW5MaXZlTW9kZVJ1bm5lck11bHRpcGxlVGltZXNdOiAnQ2Fubm90IGxhdW5jaCB0aGUgc2FtZSBsaXZlIG1vZGUgaW5zdGFuY2Ugb2YgdGhlIFRlc3RDYWZlIHRlc3QgcnVubmVyIG11bHRpcGxlIHRpbWVzLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmJyb3dzZXJEaXNjb25uZWN0ZWRdOiAgICAgICAgICAgICAgICAgICdUaGUge3VzZXJBZ2VudH0gYnJvd3NlciBkaXNjb25uZWN0ZWQuIElmIHlvdSBkaWQgbm90IGNsb3NlIHRoZSBicm93c2VyIHlvdXJzZWxmLCBicm93c2VyIHBlcmZvcm1hbmNlIG9yIG5ldHdvcmsgaXNzdWVzIG1heSBiZSBhdCBmYXVsdC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RSdW5BZ2FpbnN0RGlzY29ubmVjdGVkQnJvd3NlcnNdOiAnVGhlIGZvbGxvd2luZyBicm93c2VycyBkaXNjb25uZWN0ZWQ6IHt1c2VyQWdlbnRzfS4gQ2Fubm90IHJ1biBmdXJ0aGVyIHRlc3RzLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnRlc3RSdW5SZXF1ZXN0SW5EaXNjb25uZWN0ZWRCcm93c2VyXTogICdcInticm93c2VyfVwiIGRpc2Nvbm5lY3RlZCBkdXJpbmcgdGVzdCBleGVjdXRpb24uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RXN0YWJsaXNoQnJvd3NlckNvbm5lY3Rpb25dOiAgICAgJ0Nhbm5vdCBlc3RhYmxpc2ggb25lIG9yIG1vcmUgYnJvd3NlciBjb25uZWN0aW9ucy4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kQnJvd3Nlcl06ICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGZpbmQgdGhlIGJyb3dzZXIuIFwie2Jyb3dzZXJ9XCIgaXMgbmVpdGhlciBhIGtub3duIGJyb3dzZXIgYWxpYXMsIG5vciBhIHBhdGggdG8gYW4gZXhlY3V0YWJsZSBmaWxlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmJyb3dzZXJQcm92aWRlck5vdEZvdW5kXTogICAgICAgICAgICAgICdDYW5ub3QgZmluZCB0aGUgXCJ7cHJvdmlkZXJOYW1lfVwiIGJyb3dzZXIgcHJvdmlkZXIuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuYnJvd3Nlck5vdFNldF06ICAgICAgICAgICAgICAgICAgICAgICAgJ1lvdSBoYXZlIG5vdCBzcGVjaWZpZWQgYSBicm93c2VyLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnRlc3RGaWxlc05vdEZvdW5kXTogICAgICAgICAgICAgICAgICAgICdDb3VsZCBub3QgZmluZCB0ZXN0IGZpbGVzIGF0IHRoZSBmb2xsb3dpbmcgbG9jYXRpb246IFwie2N3ZH1cIi5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NoZWNrIHBhdHRlcm5zIGZvciBlcnJvcnM6XFxuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7c291cmNlTGlzdH1cXG5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29yIGxhdW5jaCBUZXN0Q2FmZSBmcm9tIGEgZGlmZmVyZW50IGRpcmVjdG9yeS5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB0byBzcGVjaWZ5IHRlc3QgbG9jYXRpb25zLCBzZWUgJHtET0NVTUVOVEFUSU9OX0xJTktTLlRFU1RfU09VUkNFX1BBUkFNRVRFUn0uYCxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5ub1Rlc3RzVG9SdW5dOiBcIlNvdXJjZSBmaWxlcyBkbyBub3QgY29udGFpbiB2YWxpZCAnZml4dHVyZScgYW5kICd0ZXN0JyBkZWNsYXJhdGlvbnMuXCIsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMubm9UZXN0c1RvUnVuRHVlRmlsdGVyaW5nXTogJ05vIHRlc3RzIG1hdGNoIHlvdXIgZmlsdGVyLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgU2VlICR7RE9DVU1FTlRBVElPTl9MSU5LUy5GSUxURVJfU0VUVElOR1N9LmAsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RmluZFJlcG9ydGVyRm9yQWxpYXNdOiAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwie25hbWV9XCIgcmVwb3J0ZXIgZG9lcyBub3QgZXhpc3QuIENoZWNrIHRoZSByZXBvcnRlciBwYXJhbWV0ZXIgZm9yIGVycm9ycy4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5tdWx0aXBsZVNhbWVTdHJlYW1SZXBvcnRlcnNdOiAgICAgICAgICAgICAgICAgICAgICAgICdSZXBvcnRlcnMgY2Fubm90IHNoYXJlIG91dHB1dCBzdHJlYW1zLiBUaGUgZm9sbG93aW5nIHJlcG9ydGVycyBpbnRlcmZlcmUgd2l0aCBvbmUgYW5vdGhlcjogXCJ7cmVwb3J0ZXJzfVwiLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm9wdGlvblZhbHVlSXNOb3RWYWxpZFJlZ0V4cF06ICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcIntvcHRpb25OYW1lfVwiIG9wdGlvbiBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgcmVndWxhciBleHByZXNzaW9uLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm9wdGlvblZhbHVlSXNOb3RWYWxpZEtleVZhbHVlXTogICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcIntvcHRpb25OYW1lfVwiIG9wdGlvbiBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQga2V5LXZhbHVlIHBhaXIuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZFF1YXJhbnRpbmVPcHRpb25dOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwie29wdGlvbk5hbWV9XCIgb3B0aW9uIGRvZXMgbm90IGV4aXN0LiBTcGVjaWZ5IFwiYXR0ZW1wdExpbWl0XCIgYW5kIFwic3VjY2Vzc1RocmVzaG9sZFwiIHRvIGNvbmZpZ3VyZSBxdWFyYW50aW5lIG1vZGUuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZFF1YXJhbnRpbmVQYXJhbWV0ZXJzUmF0aW9dOiAgICAgICAgICAgICAgICAgICAnVGhlIHZhbHVlIG9mIFwiYXR0ZW1wdExpbWl0XCIgKHthdHRlbXB0TGltaXR9KSBzaG91bGQgYmUgZ3JlYXRlciB0aGVuIHRoZSB2YWx1ZSBvZiBcInN1Y2Nlc3NUaHJlc2hvbGRcIiAoe3N1Y2Nlc3NUaHJlc2hvbGR9KS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkQXR0ZW1wdExpbWl0VmFsdWVdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgXCJ7YXR0ZW1wdExpbWl0fVwiIHBhcmFtZXRlciBvbmx5IGFjY2VwdHMgdmFsdWVzIG9mIHtNSU5fQVRURU1QVF9MSU1JVH0gYW5kIHVwLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRTdWNjZXNzVGhyZXNob2xkVmFsdWVdOiAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcIntzdWNjZXNzVGhyZXNob2xkfVwiIHBhcmFtZXRlciBvbmx5IGFjY2VwdHMgdmFsdWVzIG9mIHtNSU5fU1VDQ0VTU19USFJFU0hPTER9IGFuZCB1cC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkU3BlZWRWYWx1ZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTcGVlZCBzaG91bGQgYmUgYSBudW1iZXIgYmV0d2VlbiAwLjAxIGFuZCAxLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRDb25jdXJyZW5jeUZhY3Rvcl06ICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBjb25jdXJyZW5jeSBmYWN0b3Igc2hvdWxkIGJlIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RGl2aWRlUmVtb3Rlc0NvdW50QnlDb25jdXJyZW5jeV06ICAgICAgICAgICAgICAnVGhlIG51bWJlciBvZiByZW1vdGUgYnJvd3NlcnMgc2hvdWxkIGJlIGRpdmlzaWJsZSBieSB0aGUgY29uY3VycmVuY3kgZmFjdG9yLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFNldENvbmN1cnJlbmN5V2l0aENEUFBvcnRdOiAgICAgICAgICAgICAgICAgICAgJ1RoZSB2YWx1ZSBvZiB0aGUgXCJjb25jdXJyZW5jeVwiIG9wdGlvbiBpbmNsdWRlcyB0aGUgQ0RQIHBvcnQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMucG9ydHNPcHRpb25SZXF1aXJlc1R3b051bWJlcnNdOiAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwiLS1wb3J0c1wiIGFyZ3VtZW50IGFjY2VwdHMgdHdvIHZhbHVlcyBhdCBhIHRpbWUuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMucG9ydElzTm90RnJlZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUG9ydCB7cG9ydE51bX0gaXMgb2NjdXBpZWQgYnkgYW5vdGhlciBwcm9jZXNzLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRIb3N0bmFtZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCByZXNvbHZlIGhvc3RuYW1lIFwie2hvc3RuYW1lfVwiLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRTcGVjaWZpZWRUZXN0U291cmNlXTogICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBmaW5kIGEgdGVzdCBmaWxlIGF0IFwie3BhdGh9XCIuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50RnVuY3Rpb25Db2RlSXNOb3RBRnVuY3Rpb25dOiAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGluaXRpYWxpemUgYSBDbGllbnRGdW5jdGlvbiBiZWNhdXNlIHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gaXMge3R5cGV9LCBhbmQgbm90IGEgZnVuY3Rpb24uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuc2VsZWN0b3JJbml0aWFsaXplZFdpdGhXcm9uZ1R5cGVdOiAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGluaXRpYWxpemUgYSBTZWxlY3RvciBiZWNhdXNlIHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gaXMge3R5cGV9LCBhbmQgbm90IG9uZSBvZiB0aGUgZm9sbG93aW5nOiBhIENTUyBzZWxlY3RvciBzdHJpbmcsIGEgU2VsZWN0b3Igb2JqZWN0LCBhIG5vZGUgc25hcHNob3QsIGEgZnVuY3Rpb24sIG9yIGEgUHJvbWlzZSByZXR1cm5lZCBieSBhIFNlbGVjdG9yLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNsaWVudEZ1bmN0aW9uQ2Fubm90UmVzb2x2ZVRlc3RSdW5dOiAgICAgICAgICAgICAgICAgXCJ7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGNhbm5vdCBpbXBsaWNpdGx5IHJlc29sdmUgdGhlIHRlc3QgcnVuIGluIGNvbnRleHQgb2Ygd2hpY2ggaXQgc2hvdWxkIGJlIGV4ZWN1dGVkLiBJZiB5b3UgbmVlZCB0byBjYWxsIHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gZnJvbSB0aGUgTm9kZS5qcyBBUEkgY2FsbGJhY2ssIHBhc3MgdGhlIHRlc3QgY29udHJvbGxlciBtYW51YWxseSB2aWEgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSdzIGAud2l0aCh7IGJvdW5kVGVzdFJ1bjogdCB9KWAgbWV0aG9kIGZpcnN0LiBOb3RlIHRoYXQgeW91IGNhbm5vdCBleGVjdXRlIHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gb3V0c2lkZSB0aGUgdGVzdCBjb2RlLlwiLFxuICAgIFtSVU5USU1FX0VSUk9SUy5yZXF1ZXN0Q2Fubm90UmVzb2x2ZVRlc3RSdW5dOiAgICAgICAgICAgICAgICAgICAgICAgIFwiJ3JlcXVlc3QnIGNhbm5vdCBpbXBsaWNpdGx5IHJlc29sdmUgdGhlIHRlc3QgcnVuIGluIGNvbnRleHQgb2Ygd2hpY2ggaXQgc2hvdWxkIGJlIGV4ZWN1dGVkLiBOb3RlIHRoYXQgeW91IGNhbm5vdCBleGVjdXRlICdyZXF1ZXN0JyBpbiB0aGUgZXhwZXJpbWVudGFsIGRlYnVnIG1vZGUuXCIsXG4gICAgW1JVTlRJTUVfRVJST1JTLnJlZ2VuZXJhdG9ySW5DbGllbnRGdW5jdGlvbkNvZGVdOiAgICAgICAgICAgICAgICAgICAgYHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY29kZSwgYXJndW1lbnRzIG9yIGRlcGVuZGVuY2llcyBjYW5ub3QgY29udGFpbiBnZW5lcmF0b3JzIG9yIFwiYXN5bmMvYXdhaXRcIiBzeW50YXggKHVzZSBQcm9taXNlcyBpbnN0ZWFkKS5gLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkQ2xpZW50RnVuY3Rpb25UZXN0UnVuQmluZGluZ106ICAgICAgICAgICAgICAgICdDYW5ub3QgcmVzb2x2ZSB0aGUgXCJib3VuZFRlc3RSdW5cIiBvcHRpb24gYmVjYXVzZSBpdHMgdmFsdWUgaXMgbm90IGEgdGVzdCBjb250cm9sbGVyLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRWYWx1ZVR5cGVdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tzbXRoZ30gKHthY3R1YWx9KSBpcyBub3Qgb2YgZXhwZWN0ZWQgdHlwZSAoe3R5cGV9KS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy51bnN1cHBvcnRlZFVybFByb3RvY29sXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIHt3aGF0fTogXCJ7dXJsfVwiLiBUZXN0Q2FmZSBjYW5ub3QgZXhlY3V0ZSB0aGUgdGVzdCBiZWNhdXNlIHRoZSB7d2hhdH0gaW5jbHVkZXMgdGhlIHtwcm90b2NvbH0gcHJvdG9jb2wuIFRlc3RDYWZlIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvdG9jb2xzOiBodHRwOi8vLCBodHRwczovLyBhbmQgZmlsZTovLy4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy50ZXN0Q29udHJvbGxlclByb3h5Q2Fubm90UmVzb2x2ZVRlc3RSdW5dOiAgICAgICAgICAgIGBDYW5ub3QgaW1wbGljaXRseSByZXNvbHZlIHRoZSB0ZXN0IHJ1biBpbiB0aGUgY29udGV4dCBvZiB3aGljaCB0aGUgdGVzdCBjb250cm9sbGVyIGFjdGlvbiBzaG91bGQgYmUgZXhlY3V0ZWQuIFVzZSB0ZXN0IGZ1bmN0aW9uJ3MgJ3QnIGFyZ3VtZW50IGluc3RlYWQuYCxcbiAgICBbUlVOVElNRV9FUlJPUlMudGltZUxpbWl0ZWRQcm9taXNlVGltZW91dEV4cGlyZWRdOiAgICAgICAgICAgICAgICAgICAnQSBQcm9taXNlIHRpbWVkIG91dC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RTZXRWaWRlb09wdGlvbnNXaXRob3V0QmFzZVZpZGVvUGF0aFNwZWNpZmllZF06ICdZb3UgY2Fubm90IG1hbmFnZSBhZHZhbmNlZCB2aWRlbyBwYXJhbWV0ZXJzIHdoZW4gdGhlIHZpZGVvIHJlY29yZGluZyBjYXBhYmlsaXR5IGlzIG9mZi4gU3BlY2lmeSB0aGUgcm9vdCBzdG9yYWdlIGZvbGRlciBmb3IgdmlkZW8gY29udGVudCB0byBlbmFibGUgdmlkZW8gcmVjb3JkaW5nLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm11bHRpcGxlQVBJTWV0aG9kQ2FsbEZvcmJpZGRlbl06ICAgICAgICAgICAgICAgICAgICAgJ1lvdSBjYW5ub3QgY2FsbCB0aGUgXCJ7bWV0aG9kTmFtZX1cIiBtZXRob2QgbW9yZSB0aGFuIG9uY2UuIFNwZWNpZnkgYW4gYXJyYXkgb2YgcGFyYW1ldGVycyBpbnN0ZWFkLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRSZXBvcnRlck91dHB1dF06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTcGVjaWZ5IGEgZmlsZSBuYW1lIG9yIGEgd3JpdGFibGUgc3RyZWFtIGFzIHRoZSByZXBvcnRlcidzIG91dHB1dCB0YXJnZXQuXCIsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFJlYWRTU0xDZXJ0RmlsZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VuYWJsZSB0byByZWFkIHRoZSBmaWxlIHJlZmVyZW5jZWQgYnkgdGhlIFwie29wdGlvbn1cIiBzc2wgb3B0aW9uIChcIntwYXRofVwiKS4gRXJyb3IgZGV0YWlsczpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tlcnJ9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RQcmVwYXJlVGVzdHNEdWVUb0Vycm9yXTogJ0Nhbm5vdCBwcmVwYXJlIHRlc3RzIGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tlcnJNZXNzYWdlfScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90UGFyc2VSYXdGaWxlXTogJ0Nhbm5vdCBwYXJzZSBhIHJhdyB0ZXN0IGZpbGUgYXQgXCJ7cGF0aH1cIiBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcjpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy50ZXN0ZWRBcHBGYWlsZWRXaXRoRXJyb3JdOiAnVGhlIHdlYiBhcHBsaWNhdGlvbiBmYWlsZWQgd2l0aCB0aGUgZm9sbG93aW5nIGVycm9yOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7ZXJyTWVzc2FnZX0nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLnVuYWJsZVRvT3BlbkJyb3dzZXJdOiAnVW5hYmxlIHRvIG9wZW4gdGhlIFwie2FsaWFzfVwiIGJyb3dzZXIgZHVlIHRvIHRoZSBmb2xsb3dpbmcgZXJyb3I6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5yZXF1ZXN0SG9va0NvbmZpZ3VyZUFQSUVycm9yXTogJ0F0dGVtcHQgdG8gY29uZmlndXJlIGEgcmVxdWVzdCBob29rIHJlc3VsdGVkIGluIHRoZSBmb2xsb3dpbmcgZXJyb3I6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne3JlcXVlc3RIb29rTmFtZX06IHtlcnJNc2d9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5mb3JiaWRkZW5DaGFyYXRlcnNJblNjcmVlbnNob3RQYXRoXTogJ1RoZXJlIGFyZSBmb3JiaWRkZW4gY2hhcmFjdGVycyBpbiB0aGUgXCJ7c2NyZWVuc2hvdFBhdGh9XCIge3NjcmVlbnNob3RQYXRoVHlwZX06XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHtmb3JiaWRkZW5DaGFyc0Rlc2NyaXB0aW9ufScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RmluZEZGTVBFR106ICdUZXN0Q2FmZSBjYW5ub3QgcmVjb3JkIHZpZGVvcyBiZWNhdXNlIGl0IGNhbm5vdCBsb2NhdGUgdGhlIEZGbXBlZyBleGVjdXRhYmxlLiBUcnkgb25lIG9mIHRoZSBmb2xsb3dpbmcgc29sdXRpb25zOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyogYWRkIHRoZSBwYXRoIG9mIHRoZSBGRm1wZWcgaW5zdGFsbGF0aW9uIGRpcmVjdG9yeSB0byB0aGUgUEFUSCBlbnZpcm9ubWVudCB2YXJpYWJsZSxcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcqIHNwZWNpZnkgdGhlIHBhdGggb2YgdGhlIEZGbXBlZyBleGVjdXRhYmxlIGluIHRoZSBGRk1QRUdfUEFUSCBlbnZpcm9ubWVudCB2YXJpYWJsZSBvciB0aGUgZmZtcGVnUGF0aCBvcHRpb24sXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKiBpbnN0YWxsIHRoZSBAZmZtcGVnLWluc3RhbGxlci9mZm1wZWcgbnBtIHBhY2thZ2UuJyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kVHlwZXNjcmlwdENvbmZpZ3VyYXRpb25GaWxlXTogICAgICAgICAgICAnXCJ7ZmlsZVBhdGh9XCIgaXMgbm90IGEgdmFsaWQgVHlwZVNjcmlwdCBjb25maWd1cmF0aW9uIGZpbGUuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50U2NyaXB0SW5pdGlhbGl6ZXJJc05vdFNwZWNpZmllZF06ICAgICAgICAgICAgJ0luaXRpYWxpemUgeW91ciBjbGllbnQgc2NyaXB0IHdpdGggb25lIG9mIHRoZSBmb2xsb3dpbmc6IGEgSmF2YVNjcmlwdCBzY3JpcHQsIGEgSmF2YVNjcmlwdCBmaWxlIHBhdGgsIG9yIHRoZSBuYW1lIG9mIGEgSmF2YVNjcmlwdCBtb2R1bGUuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50U2NyaXB0QmFzZVBhdGhJc05vdFNwZWNpZmllZF06ICAgICAgICAgICAgICAgJ1NwZWNpZnkgdGhlIGJhc2UgcGF0aCBmb3IgdGhlIGNsaWVudCBzY3JpcHQgZmlsZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRTY3JpcHRJbml0aWFsaXplck11bHRpcGxlQ29udGVudFNvdXJjZXNdOiAgICAnQ2xpZW50IHNjcmlwdHMgY2FuIG9ubHkgaGF2ZSBvbmUgaW5pdGlhbGl6ZXI6IEphdmFTY3JpcHQgY29kZSwgYSBKYXZhU2NyaXB0IGZpbGUgcGF0aCwgb3IgdGhlIG5hbWUgb2YgYSBKYXZhU2NyaXB0IG1vZHVsZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RMb2FkQ2xpZW50U2NyaXB0RnJvbVBhdGhdOiAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGxvYWQgYSBjbGllbnQgc2NyaXB0IGZyb20ge3BhdGh9LlxcbntlcnJvck1lc3NhZ2V9JyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50U2NyaXB0TW9kdWxlRW50cnlQb2ludFBhdGhDYWxjdWxhdGlvbkVycm9yXTogJ0EgY2xpZW50IHNjcmlwdCB0cmllZCB0byBsb2FkIGEgSmF2YVNjcmlwdCBtb2R1bGUgdGhhdCBUZXN0Q2FmZSBjYW5ub3QgbG9jYXRlOlxcblxcbntlcnJvck1lc3NhZ2V9LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm1ldGhvZElzTm90QXZhaWxhYmxlRm9yQW5JUENIb3N0XTogICAgICAgICAgICAgICAgICdUaGlzIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIG9uIGEgc2VydmljZSBob3N0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnRvb0xhcmdlSVBDUGF5bG9hZF06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIHBheWxvYWQgaXMgdG9vIGxhcmdlIHRvIGZvcm0gYW4gSVBDIHBhY2tldC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5tYWxmb3JtZWRJUENNZXNzYWdlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHByb2Nlc3MgYSBtYWxmb3JtZWQgSVBDIG1lc3NhZ2UuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudW5leHBlY3RlZElQQ0hlYWRQYWNrZXRdOiAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBjcmVhdGUgYW4gSVBDIG1lc3NhZ2UgZHVlIHRvIGFuIHVuZXhwZWN0ZWQgSVBDIGhlYWQgcGFja2V0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnVuZXhwZWN0ZWRJUENCb2R5UGFja2V0XTogICAgICAgICAgICAgICAgICAgICAgICAgICdDYW5ub3QgY3JlYXRlIGFuIElQQyBtZXNzYWdlIGR1ZSB0byBhbiB1bmV4cGVjdGVkIElQQyBib2R5IHBhY2tldC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy51bmV4cGVjdGVkSVBDVGFpbFBhY2tldF06ICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGNyZWF0ZSBhbiBJUEMgbWVzc2FnZSBkdWUgdG8gYW4gdW5leHBlY3RlZCBJUEMgdGFpbCBwYWNrZXQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90UnVuTG9jYWxOb25IZWFkbGVzc0Jyb3dzZXJXaXRob3V0RGlzcGxheV06XG4gICAgICAgICdZb3VyIExpbnV4IHZlcnNpb24gZG9lcyBub3QgaGF2ZSBhIGdyYXBoaWMgc3Vic3lzdGVtIHRvIHJ1biB7YnJvd3NlckFsaWFzfSB3aXRoIGEgR1VJLiAnICtcbiAgICAgICAgJ1lvdSBjYW4gbGF1bmNoIHRoZSBicm93c2VyIGluIGhlYWRsZXNzIG1vZGUuICcgK1xuICAgICAgICAnSWYgeW91IHVzZSBhIHBvcnRhYmxlIGJyb3dzZXIgZXhlY3V0YWJsZSwgJyArXG4gICAgICAgIFwic3BlY2lmeSB0aGUgYnJvd3NlciBhbGlhcyBiZWZvcmUgdGhlIHBhdGggaW5zdGVhZCBvZiB0aGUgJ3BhdGgnIHByZWZpeC4gXCIgK1xuICAgICAgICBgRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAke0RPQ1VNRU5UQVRJT05fTElOS1MuSEVBRExFU1NfTU9ERX1gLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLnVuY2F1Z2h0RXJyb3JJblJlcG9ydGVyXTogICAgICAgICAgICdUaGUgXCJ7bWV0aG9kTmFtZX1cIiBtZXRob2Qgb2YgdGhlIFwie3JlcG9ydGVyTmFtZX1cIiByZXBvcnRlciBwcm9kdWNlZCBhbiB1bmNhdWdodCBlcnJvci4gRXJyb3IgZGV0YWlsczpcXG57b3JpZ2luYWxFcnJvcn0nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5yb2xlSW5pdGlhbGl6ZWRXaXRoUmVsYXRpdmVVcmxdOiAgICAnWW91IGNhbm5vdCBzcGVjaWZ5IHJlbGF0aXZlIGxvZ2luIHBhZ2UgVVJMcyBpbiB0aGUgUm9sZSBjb25zdHJ1Y3Rvci4gVXNlIGFuIGFic29sdXRlIFVSTC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy50eXBlU2NyaXB0Q29tcGlsZXJMb2FkaW5nRXJyb3JdOiAgICAnQ2Fubm90IGxvYWQgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXIuXFxue29yaWdpbkVycm9yTWVzc2FnZX0uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90Q3VzdG9taXplU3BlY2lmaWVkQ29tcGlsZXJzXTogJ1lvdSBjYW5ub3Qgc3BlY2lmeSBvcHRpb25zIGZvciB0aGUge25vbmN1c3RvbWl6YWJsZUNvbXBpbGVyTGlzdH0gY29tcGlsZXJ7c3VmZml4fS4nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEVuYWJsZVJldHJ5VGVzdFBhZ2VzT3B0aW9uXTpcbiAgICAgICAgJ0Nhbm5vdCBlbmFibGUgdGhlIFxcJ3JldHJ5VGVzdFBhZ2VzXFwnIG9wdGlvbi4gQXBwbHkgb25lIG9mIHRoZSBmb2xsb3dpbmcgdHdvIHNvbHV0aW9uczpcXG4nICtcbiAgICAgICAgJy0tIHNldCBcXCdsb2NhbGhvc3RcXCcgYXMgdGhlIHZhbHVlIG9mIHRoZSBcXCdob3N0bmFtZVxcJyBvcHRpb25cXG4nICtcbiAgICAgICAgJy0tIHJ1biBUZXN0Q2FmZSBvdmVyIEhUVFBTXFxuJyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5icm93c2VyQ29ubmVjdGlvbkVycm9yXTogICAgICAgICAgICAgICAne29yaWdpbkVycm9yTWVzc2FnZX1cXG57bnVtT2ZOb3RPcGVuZWRDb25uZWN0aW9ufSBvZiB7bnVtT2ZBbGxDb25uZWN0aW9uc30gYnJvd3NlciBjb25uZWN0aW9ucyBoYXZlIG5vdCBiZWVuIGVzdGFibGlzaGVkOlxcbntsaXN0T2ZOb3RPcGVuZWRDb25uZWN0aW9uc31cXG5cXG5IaW50czpcXG57bGlzdE9mSGludHN9JyxcbiAgICBbQnJvd3NlckNvbm5lY3Rpb25FcnJvckhpbnQuVG9vSGlnaENvbmN1cnJlbmN5RmFjdG9yXTogJ1RoZSBob3N0IG1hY2hpbmUgbWF5IG5vdCBiZSBwb3dlcmZ1bCBlbm91Z2ggdG8gaGFuZGxlIHRoZSBzcGVjaWZpZWQgY29uY3VycmVuY3kgZmFjdG9yICh7Y29uY3VycmVuY3lGYWN0b3J9KS4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUcnkgdG8gZGVjcmVhc2UgdGhlIGNvbmN1cnJlbmN5IGZhY3RvciBvciBhbGxvY2F0ZSBtb3JlIGNvbXB1dGluZyByZXNvdXJjZXMgdG8gdGhlIGhvc3QgbWFjaGluZS4nLFxuICAgIFtCcm93c2VyQ29ubmVjdGlvbkVycm9ySGludC5Vc2VCcm93c2VySW5pdE9wdGlvbl06ICAgICdJbmNyZWFzZSB0aGUgdmFsdWUgb2YgdGhlIFwiYnJvd3NlckluaXRUaW1lb3V0XCIgb3B0aW9uIGlmIGl0IGlzIHRvbyBsb3cgKGN1cnJlbnRseToge2Jyb3dzZXJJbml0VGltZW91dE1zZ30pLiBUaGlzIG9wdGlvbiBkZXRlcm1pbmVzIGhvdyBsb25nIFRlc3RDYWZlIHdhaXRzIGZvciBicm93c2VycyB0byBiZSByZWFkeS4nLFxuICAgIFtCcm93c2VyQ29ubmVjdGlvbkVycm9ySGludC5SZXN0RXJyb3JDYXVzZXNdOiAgICAgICAgICdUaGUgZXJyb3IgY2FuIGFsc28gYmUgY2F1c2VkIGJ5IG5ldHdvcmsgaXNzdWVzIG9yIHJlbW90ZSBkZXZpY2UgZmFpbHVyZS4gTWFrZSBzdXJlIHRoYXQgeW91ciBuZXR3b3JrIGNvbm5lY3Rpb24gaXMgc3RhYmxlIGFuZCB5b3UgY2FuIHJlYWNoIHRoZSByZW1vdGUgZGV2aWNlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRUZXN0Y2FmZUNvbmZpZ3VyYXRpb25GaWxlXTogJ0Nhbm5vdCBsb2NhdGUgYSBUZXN0Q2FmZSBjb25maWd1cmF0aW9uIGZpbGUgYXQge2ZpbGVQYXRofS4gRWl0aGVyIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0LCBvciB0aGUgcGF0aCBpcyBpbnZhbGlkLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmRhc2hib2FyZFRva2VuSW5KU09OXTogICAgICAgICAgICAgICAgJ0luc2VjdXJlIHRva2VuIGRlY2xhcmF0aW9uOiBjYW5ub3QgZGVjbGFyZSBhIERhc2hib2FyZCB0b2tlbiBpbiBhIEpTT04gY29uZmlndXJhdGlvbiBmaWxlLiBVc2UgYSBKYXZhU2NyaXB0IGNvbmZpZ3VyYXRpb24gZmlsZSwgb3IgZGVjbGFyZSBhIERhc2hib2FyZCB0b2tlbiB3aXRoIG9uZSBvZiB0aGUgZm9sbG93aW5nOiB0aGUgQ0xJLCB0aGUgVGVzdCBSdW5uZXIgQVBJLCB0aGUgVEVTVENBRkVfREFTSEJPQVJEX1RPS0VOIGVudmlyb25tZW50IHZhcmlhYmxlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnJlbGF0aXZlQmFzZVVybF06ICAgICAgICAgICAgICAgICAgICAgJ1RoZSB2YWx1ZSBvZiB0aGUgYmFzZVVybCBhcmd1bWVudCBjYW5ub3QgYmUgcmVsYXRpdmU6IFwie2Jhc2VVcmx9XCInLFxuICAgIFtSVU5USU1FX0VSUk9SUy5yZXF1ZXN0VXJsSW52YWxpZFZhbHVlRXJyb3JdOiAgICAgICAgICdSZXF1ZXN0ZWQgdXJsIGlzblxcJ3QgdmFsaWQgKHthY3R1YWxWYWx1ZX0pLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnJlcXVlc3RSdW50aW1lRXJyb3JdOiAgICAgICAgICAgICAgICAgJ1JlcXVlc3RlZCB3YXMgaW50ZXJydXB0ZWQgd2l0aCBlcnJvcjpcXG57bWVzc2FnZX0nLFxufTtcbiJdfQ==