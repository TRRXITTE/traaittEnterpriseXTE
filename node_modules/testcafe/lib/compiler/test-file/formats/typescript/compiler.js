"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
const os_family_1 = __importDefault(require("os-family"));
const api_based_1 = __importDefault(require("../../api-based"));
const compiler_1 = __importDefault(require("../es-next/compiler"));
const typescript_configuration_1 = __importDefault(require("../../../../configuration/typescript-configuration"));
const runtime_1 = require("../../../../errors/runtime");
const types_1 = require("../../../../errors/types");
const debug_1 = __importDefault(require("debug"));
const test_page_url_1 = require("../../../../api/test-page-url");
const exportble_lib_path_1 = __importDefault(require("../../exportble-lib-path"));
const disable_v8_optimization_note_1 = __importDefault(require("../../disable-v8-optimization-note"));
// NOTE: For type definitions only
const typescript_1 = require("typescript");
function testcafeImportPathReplacer() {
    return context => {
        const visit = (node) => {
            var _a;
            // @ts-ignore
            if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.kind) === typescript_1.SyntaxKind.ImportDeclaration && node.kind === typescript_1.SyntaxKind.StringLiteral && node.text === 'testcafe')
                return typescript_1.createStringLiteral(exportble_lib_path_1.default);
            return typescript_1.visitEachChild(node, child => visit(child), context);
        };
        return node => typescript_1.visitNode(node, visit);
    };
}
function disableV8OptimizationCodeAppender() {
    return () => {
        const visit = (node) => {
            const evalStatement = typescript_1.createExpressionStatement(typescript_1.createCall(typescript_1.createIdentifier('eval'), void 0, [typescript_1.createStringLiteral('')]));
            const evalStatementWithComment = typescript_1.addSyntheticLeadingComment(evalStatement, typescript_1.SyntaxKind.MultiLineCommentTrivia, disable_v8_optimization_note_1.default, true);
            // @ts-ignore
            return typescript_1.updateSourceFileNode(node, [...node.statements, evalStatementWithComment]);
        };
        return node => typescript_1.visitNode(node, visit);
    };
}
const DEBUG_LOGGER = debug_1.default('testcafe:compiler:typescript');
const RENAMED_DEPENDENCIES_MAP = new Map([['testcafe', exportble_lib_path_1.default]]);
const DEFAULT_TYPESCRIPT_COMPILER_PATH = 'typescript';
class TypeScriptTestFileCompiler extends api_based_1.default {
    constructor(compilerOptions, { isCompilerServiceMode, baseUrl } = {}) {
        super({ isCompilerServiceMode, baseUrl });
        // NOTE: At present, it's necessary create an instance TypeScriptTestFileCompiler
        // to collect a list of supported test file extensions.
        // So all compilers creates 2 times: first time - for collecting all supported file extensions,
        // second one - for compiling tests.
        // In future, need to rewrite 'getSupportedExtension' method as static.
        const configPath = compilerOptions && compilerOptions.configPath || null;
        this._customCompilerOptions = compilerOptions && compilerOptions.options;
        this._tsConfig = new typescript_configuration_1.default(configPath, isCompilerServiceMode);
        this._compilerPath = TypeScriptTestFileCompiler._getCompilerPath(compilerOptions);
    }
    static _getCompilerPath(compilerOptions) {
        let compilerPath = compilerOptions && compilerOptions.customCompilerModulePath;
        if (!compilerPath || compilerPath === DEFAULT_TYPESCRIPT_COMPILER_PATH)
            return DEFAULT_TYPESCRIPT_COMPILER_PATH;
        // NOTE: if the relative path to custom TypeScript compiler module is specified
        // then we will resolve the path from the root of the 'testcafe' module
        if (test_page_url_1.isRelative(compilerPath)) {
            const testcafeRootFolder = path_1.default.resolve(__dirname, '../../../../../');
            compilerPath = path_1.default.resolve(testcafeRootFolder, compilerPath);
        }
        return compilerPath;
    }
    _loadTypeScriptCompiler() {
        try {
            return require(this._compilerPath);
        }
        catch (err) {
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.typeScriptCompilerLoadingError, err.message);
        }
    }
    static _normalizeFilename(filename) {
        filename = path_1.default.resolve(filename);
        if (os_family_1.default.win)
            filename = filename.toLowerCase();
        return filename;
    }
    static _getTSDefsPath() {
        return TypeScriptTestFileCompiler._normalizeFilename(path_1.default.resolve(__dirname, '../../../../../ts-defs/index.d.ts'));
    }
    _reportErrors(diagnostics) {
        // NOTE: lazy load the compiler
        const ts = this._loadTypeScriptCompiler();
        let errMsg = 'TypeScript compilation failed.\n';
        diagnostics.forEach(d => {
            const message = ts.flattenDiagnosticMessageText(d.messageText, '\n');
            const file = d.file;
            if (file && d.start !== void 0) {
                const { line, character } = file.getLineAndCharacterOfPosition(d.start);
                errMsg += `${file.fileName} (${line + 1}, ${character + 1}): `;
            }
            errMsg += `${message}\n`;
        });
        throw new Error(errMsg);
    }
    _compileCodeForTestFiles(testFilesInfo) {
        return this._tsConfig.init(this._customCompilerOptions)
            .then(() => {
            return super._compileCodeForTestFiles(testFilesInfo);
        });
    }
    _compileFilesToCache(ts, filenames) {
        const opts = this._tsConfig.getOptions();
        const program = ts.createProgram([TypeScriptTestFileCompiler.tsDefsPath, ...filenames], opts);
        DEBUG_LOGGER('version: %s', ts.version);
        DEBUG_LOGGER('options: %O', opts);
        program.getSourceFiles().forEach(sourceFile => {
            // @ts-ignore A hack to allow import globally installed TestCafe in tests
            sourceFile.renamedDependencies = RENAMED_DEPENDENCIES_MAP;
        });
        const diagnostics = ts.getPreEmitDiagnostics(program);
        if (diagnostics.length)
            this._reportErrors(diagnostics);
        // NOTE: The first argument of emit() is a source file to be compiled. If it's undefined, all files in
        // <program> will be compiled. <program> contains a file specified in createProgram() plus all its dependencies.
        // This mode is much faster than compiling files one-by-one, and it is used in the tsc CLI compiler.
        program.emit(void 0, (outputName, result, writeBOM, onError, sources) => {
            if (!sources)
                return;
            const sourcePath = TypeScriptTestFileCompiler._normalizeFilename(sources[0].fileName);
            this.cache[sourcePath] = result;
        }, void 0, void 0, {
            before: this._getTypescriptTransformers(),
        });
    }
    _getTypescriptTransformers() {
        const transformers = [testcafeImportPathReplacer()];
        if (this.isCompilerServiceMode)
            transformers.push(disableV8OptimizationCodeAppender());
        return transformers;
    }
    _precompileCode(testFilesInfo) {
        DEBUG_LOGGER('path: "%s"', this._compilerPath);
        // NOTE: lazy load the compiler
        const ts = this._loadTypeScriptCompiler();
        const filenames = testFilesInfo.map(({ filename }) => filename);
        const normalizedFilenames = filenames.map(filename => TypeScriptTestFileCompiler._normalizeFilename(filename));
        const normalizedFilenamesMap = lodash_1.zipObject(normalizedFilenames, filenames);
        const uncachedFiles = normalizedFilenames
            .filter(filename => filename !== TypeScriptTestFileCompiler.tsDefsPath && !this.cache[filename])
            .map(filename => normalizedFilenamesMap[filename]);
        if (uncachedFiles.length)
            this._compileFilesToCache(ts, uncachedFiles);
        return normalizedFilenames.map(filename => this.cache[filename]);
    }
    _getRequireCompilers() {
        return {
            '.ts': (code, filename) => this._compileCode(code, filename),
            '.tsx': (code, filename) => this._compileCode(code, filename),
            '.js': (code, filename) => compiler_1.default.prototype._compileCode.call(this, code, filename),
            '.jsx': (code, filename) => compiler_1.default.prototype._compileCode.call(this, code, filename),
        };
    }
    get canPrecompile() {
        return true;
    }
    getSupportedExtension() {
        return ['.ts', '.tsx'];
    }
}
exports.default = TypeScriptTestFileCompiler;
TypeScriptTestFileCompiler.tsDefsPath = TypeScriptTestFileCompiler._getTSDefsPath();
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcGlsZXIvdGVzdC1maWxlL2Zvcm1hdHMvdHlwZXNjcmlwdC9jb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdEQUF3QjtBQUN4QixtQ0FBbUM7QUFDbkMsMERBQTJCO0FBQzNCLGdFQUEyRDtBQUMzRCxtRUFBeUQ7QUFDekQsa0hBQXlGO0FBQ3pGLHdEQUEwRDtBQUMxRCxvREFBMEQ7QUFDMUQsa0RBQTBCO0FBQzFCLGlFQUEyRDtBQUMzRCxrRkFBMkQ7QUFDM0Qsc0dBQThFO0FBRTlFLGtDQUFrQztBQUNsQywyQ0FnQm9CO0FBbUJwQixTQUFTLDBCQUEwQjtJQUMvQixPQUFPLE9BQU8sQ0FBQyxFQUFFO1FBQ2IsTUFBTSxLQUFLLEdBQVksQ0FBQyxJQUFJLEVBQXFCLEVBQUU7O1lBQy9DLGFBQWE7WUFDYixJQUFJLE9BQUEsSUFBSSxDQUFDLE1BQU0sMENBQUUsSUFBSSxNQUFLLHVCQUFVLENBQUMsaUJBQWlCLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyx1QkFBVSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFVBQVU7Z0JBQ3hILE9BQU8sZ0NBQW1CLENBQUMsNEJBQW1CLENBQUMsQ0FBQztZQUVwRCxPQUFPLDJCQUFjLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2hFLENBQUMsQ0FBQztRQUVGLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxzQkFBUyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMxQyxDQUFDLENBQUM7QUFDTixDQUFDO0FBRUQsU0FBUyxpQ0FBaUM7SUFDdEMsT0FBTyxHQUFHLEVBQUU7UUFDUixNQUFNLEtBQUssR0FBWSxDQUFDLElBQUksRUFBcUIsRUFBRTtZQUMv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LElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFFakQsT0FBTyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUVNLG9CQUFvQjtRQUN2QixPQUFPO1lBQ0gsS0FBSyxFQUFHLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDO1lBQzdELE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQztZQUM3RCxLQUFLLEVBQUcsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxrQkFBc0IsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQztZQUNwRyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxrQkFBc0IsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQztTQUN2RyxDQUFDO0lBQ04sQ0FBQztJQUVELElBQVcsYUFBYTtRQUNwQixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRU0scUJBQXFCO1FBQ3hCLE9BQU8sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDM0IsQ0FBQzs7QUFyS0wsNkNBc0tDO0FBcktrQixxQ0FBVSxHQUFHLDBCQUEwQixDQUFDLGNBQWMsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyB6aXBPYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IE9TIGZyb20gJ29zLWZhbWlseSc7XG5pbXBvcnQgQVBJQmFzZWRUZXN0RmlsZUNvbXBpbGVyQmFzZSBmcm9tICcuLi8uLi9hcGktYmFzZWQnO1xuaW1wb3J0IEVTTmV4dFRlc3RGaWxlQ29tcGlsZXIgZnJvbSAnLi4vZXMtbmV4dC9jb21waWxlcic7XG5pbXBvcnQgVHlwZXNjcmlwdENvbmZpZ3VyYXRpb24gZnJvbSAnLi4vLi4vLi4vLi4vY29uZmlndXJhdGlvbi90eXBlc2NyaXB0LWNvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHsgR2VuZXJhbEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXJyb3JzL3J1bnRpbWUnO1xuaW1wb3J0IHsgUlVOVElNRV9FUlJPUlMgfSBmcm9tICcuLi8uLi8uLi8uLi9lcnJvcnMvdHlwZXMnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IGlzUmVsYXRpdmUgfSBmcm9tICcuLi8uLi8uLi8uLi9hcGkvdGVzdC1wYWdlLXVybCc7XG5pbXBvcnQgRVhQT1JUQUJMRV9MSUJfUEFUSCBmcm9tICcuLi8uLi9leHBvcnRibGUtbGliLXBhdGgnO1xuaW1wb3J0IERJU0FCTEVfVjhfT1BUSU1JWkFUSU9OX05PVEUgZnJvbSAnLi4vLi4vZGlzYWJsZS12OC1vcHRpbWl6YXRpb24tbm90ZSc7XG5cbi8vIE5PVEU6IEZvciB0eXBlIGRlZmluaXRpb25zIG9ubHlcbmltcG9ydCBUeXBlU2NyaXB0LCB7XG4gICAgQ29tcGlsZXJPcHRpb25zVmFsdWUsXG4gICAgU3ludGF4S2luZCxcbiAgICBWaXNpdFJlc3VsdCxcbiAgICBWaXNpdG9yLFxuICAgIE5vZGUsXG4gICAgY3JlYXRlU3RyaW5nTGl0ZXJhbCxcbiAgICB2aXNpdEVhY2hDaGlsZCxcbiAgICB2aXNpdE5vZGUsXG4gICAgVHJhbnNmb3JtZXJGYWN0b3J5LFxuICAgIGNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgY3JlYXRlQ2FsbCxcbiAgICBjcmVhdGVJZGVudGlmaWVyLFxuICAgIHVwZGF0ZVNvdXJjZUZpbGVOb2RlLFxuICAgIFNvdXJjZUZpbGUsXG4gICAgYWRkU3ludGhldGljTGVhZGluZ0NvbW1lbnQsXG59IGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQgeyBEaWN0aW9uYXJ5LCBUeXBlU2NyaXB0Q29tcGlsZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uZmlndXJhdGlvbi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IE9wdGlvbmFsQ29tcGlsZXJBcmd1bWVudHMgfSBmcm9tICcuLi8uLi8uLi9pbnRlcmZhY2VzJztcblxuZGVjbGFyZSB0eXBlIFR5cGVTY3JpcHRJbnN0YW5jZSA9IHR5cGVvZiBUeXBlU2NyaXB0O1xuXG5pbnRlcmZhY2UgVGVzdEZpbGVJbmZvIHtcbiAgICBmaWxlbmFtZTogc3RyaW5nO1xufVxuXG5kZWNsYXJlIGludGVyZmFjZSBSZXF1aXJlQ29tcGlsZXJGdW5jdGlvbiB7XG4gICAgKGNvZGU6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlcXVpcmVDb21waWxlcnMge1xuICAgIFtleHRlbnNpb246IHN0cmluZ106IFJlcXVpcmVDb21waWxlckZ1bmN0aW9uO1xufVxuXG5mdW5jdGlvbiB0ZXN0Y2FmZUltcG9ydFBhdGhSZXBsYWNlcjxUIGV4dGVuZHMgTm9kZT4gKCk6IFRyYW5zZm9ybWVyRmFjdG9yeTxUPiB7XG4gICAgcmV0dXJuIGNvbnRleHQgPT4ge1xuICAgICAgICBjb25zdCB2aXNpdDogVmlzaXRvciA9IChub2RlKTogVmlzaXRSZXN1bHQ8Tm9kZT4gPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Py5raW5kID09PSBTeW50YXhLaW5kLkltcG9ydERlY2xhcmF0aW9uICYmIG5vZGUua2luZCA9PT0gU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsICYmIG5vZGUudGV4dCA9PT0gJ3Rlc3RjYWZlJylcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU3RyaW5nTGl0ZXJhbChFWFBPUlRBQkxFX0xJQl9QQVRIKTtcblxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0RWFjaENoaWxkKG5vZGUsIGNoaWxkID0+IHZpc2l0KGNoaWxkKSwgY29udGV4dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5vZGUgPT4gdmlzaXROb2RlKG5vZGUsIHZpc2l0KTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlVjhPcHRpbWl6YXRpb25Db2RlQXBwZW5kZXI8VCBleHRlbmRzIE5vZGU+ICgpOiBUcmFuc2Zvcm1lckZhY3Rvcnk8VD4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpc2l0OiBWaXNpdG9yID0gKG5vZGUpOiBWaXNpdFJlc3VsdDxOb2RlPiA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmFsU3RhdGVtZW50ID0gY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChjcmVhdGVDYWxsKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUlkZW50aWZpZXIoJ2V2YWwnKSxcbiAgICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgICAgW2NyZWF0ZVN0cmluZ0xpdGVyYWwoJycpXVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGV2YWxTdGF0ZW1lbnRXaXRoQ29tbWVudCA9IGFkZFN5bnRoZXRpY0xlYWRpbmdDb21tZW50KGV2YWxTdGF0ZW1lbnQsIFN5bnRheEtpbmQuTXVsdGlMaW5lQ29tbWVudFRyaXZpYSwgRElTQUJMRV9WOF9PUFRJTUlaQVRJT05fTk9URSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTb3VyY2VGaWxlTm9kZShub2RlLCBbLi4ubm9kZS5zdGF0ZW1lbnRzLCBldmFsU3RhdGVtZW50V2l0aENvbW1lbnRdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbm9kZSA9PiB2aXNpdE5vZGUobm9kZSwgdmlzaXQpO1xuICAgIH07XG59XG5cblxuY29uc3QgREVCVUdfTE9HR0VSID0gZGVidWcoJ3Rlc3RjYWZlOmNvbXBpbGVyOnR5cGVzY3JpcHQnKTtcblxuY29uc3QgUkVOQU1FRF9ERVBFTkRFTkNJRVNfTUFQID0gbmV3IE1hcChbWyd0ZXN0Y2FmZScsIEVYUE9SVEFCTEVfTElCX1BBVEhdXSk7XG5cbmNvbnN0IERFRkFVTFRfVFlQRVNDUklQVF9DT01QSUxFUl9QQVRIID0gJ3R5cGVzY3JpcHQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlciBleHRlbmRzIEFQSUJhc2VkVGVzdEZpbGVDb21waWxlckJhc2Uge1xuICAgIHByaXZhdGUgc3RhdGljIHRzRGVmc1BhdGggPSBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci5fZ2V0VFNEZWZzUGF0aCgpO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBfdHNDb25maWc6IFR5cGVzY3JpcHRDb25maWd1cmF0aW9uO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2NvbXBpbGVyUGF0aDogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2N1c3RvbUNvbXBpbGVyT3B0aW9ucz86IG9iamVjdDtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvciAoY29tcGlsZXJPcHRpb25zPzogVHlwZVNjcmlwdENvbXBpbGVyT3B0aW9ucywgeyBpc0NvbXBpbGVyU2VydmljZU1vZGUsIGJhc2VVcmwgfTogT3B0aW9uYWxDb21waWxlckFyZ3VtZW50cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHsgaXNDb21waWxlclNlcnZpY2VNb2RlLCBiYXNlVXJsIH0pO1xuXG4gICAgICAgIC8vIE5PVEU6IEF0IHByZXNlbnQsIGl0J3MgbmVjZXNzYXJ5IGNyZWF0ZSBhbiBpbnN0YW5jZSBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlclxuICAgICAgICAvLyB0byBjb2xsZWN0IGEgbGlzdCBvZiBzdXBwb3J0ZWQgdGVzdCBmaWxlIGV4dGVuc2lvbnMuXG4gICAgICAgIC8vIFNvIGFsbCBjb21waWxlcnMgY3JlYXRlcyAyIHRpbWVzOiBmaXJzdCB0aW1lIC0gZm9yIGNvbGxlY3RpbmcgYWxsIHN1cHBvcnRlZCBmaWxlIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIHNlY29uZCBvbmUgLSBmb3IgY29tcGlsaW5nIHRlc3RzLlxuICAgICAgICAvLyBJbiBmdXR1cmUsIG5lZWQgdG8gcmV3cml0ZSAnZ2V0U3VwcG9ydGVkRXh0ZW5zaW9uJyBtZXRob2QgYXMgc3RhdGljLlxuXG4gICAgICAgIGNvbnN0IGNvbmZpZ1BhdGggPSBjb21waWxlck9wdGlvbnMgJiYgY29tcGlsZXJPcHRpb25zLmNvbmZpZ1BhdGggfHwgbnVsbDtcblxuICAgICAgICB0aGlzLl9jdXN0b21Db21waWxlck9wdGlvbnMgPSBjb21waWxlck9wdGlvbnMgJiYgY29tcGlsZXJPcHRpb25zLm9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3RzQ29uZmlnICAgICAgICAgICAgICA9IG5ldyBUeXBlc2NyaXB0Q29uZmlndXJhdGlvbihjb25maWdQYXRoLCBpc0NvbXBpbGVyU2VydmljZU1vZGUpO1xuICAgICAgICB0aGlzLl9jb21waWxlclBhdGggICAgICAgICAgPSBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci5fZ2V0Q29tcGlsZXJQYXRoKGNvbXBpbGVyT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2dldENvbXBpbGVyUGF0aCAoY29tcGlsZXJPcHRpb25zPzogVHlwZVNjcmlwdENvbXBpbGVyT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgICAgIGxldCBjb21waWxlclBhdGggPSBjb21waWxlck9wdGlvbnMgJiYgY29tcGlsZXJPcHRpb25zLmN1c3RvbUNvbXBpbGVyTW9kdWxlUGF0aDtcblxuICAgICAgICBpZiAoIWNvbXBpbGVyUGF0aCB8fCBjb21waWxlclBhdGggPT09IERFRkFVTFRfVFlQRVNDUklQVF9DT01QSUxFUl9QQVRIKVxuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfVFlQRVNDUklQVF9DT01QSUxFUl9QQVRIO1xuXG4gICAgICAgIC8vIE5PVEU6IGlmIHRoZSByZWxhdGl2ZSBwYXRoIHRvIGN1c3RvbSBUeXBlU2NyaXB0IGNvbXBpbGVyIG1vZHVsZSBpcyBzcGVjaWZpZWRcbiAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIHJlc29sdmUgdGhlIHBhdGggZnJvbSB0aGUgcm9vdCBvZiB0aGUgJ3Rlc3RjYWZlJyBtb2R1bGVcbiAgICAgICAgaWYgKGlzUmVsYXRpdmUoY29tcGlsZXJQYXRoKSkge1xuICAgICAgICAgICAgY29uc3QgdGVzdGNhZmVSb290Rm9sZGVyID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uLy4uLy4uLy4uLy4uLycpO1xuXG4gICAgICAgICAgICBjb21waWxlclBhdGggPSBwYXRoLnJlc29sdmUodGVzdGNhZmVSb290Rm9sZGVyLCBjb21waWxlclBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVyUGF0aDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9sb2FkVHlwZVNjcmlwdENvbXBpbGVyICgpOiBUeXBlU2NyaXB0SW5zdGFuY2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmUodGhpcy5fY29tcGlsZXJQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLnR5cGVTY3JpcHRDb21waWxlckxvYWRpbmdFcnJvciwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX25vcm1hbGl6ZUZpbGVuYW1lIChmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgZmlsZW5hbWUgPSBwYXRoLnJlc29sdmUoZmlsZW5hbWUpO1xuXG4gICAgICAgIGlmIChPUy53aW4pXG4gICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIF9nZXRUU0RlZnNQYXRoICgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIuX25vcm1hbGl6ZUZpbGVuYW1lKHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi8uLi8uLi8uLi8uLi90cy1kZWZzL2luZGV4LmQudHMnKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfcmVwb3J0RXJyb3JzIChkaWFnbm9zdGljczogUmVhZG9ubHk8VHlwZVNjcmlwdC5EaWFnbm9zdGljW10+KTogdm9pZCB7XG4gICAgICAgIC8vIE5PVEU6IGxhenkgbG9hZCB0aGUgY29tcGlsZXJcbiAgICAgICAgY29uc3QgdHM6IFR5cGVTY3JpcHRJbnN0YW5jZSA9IHRoaXMuX2xvYWRUeXBlU2NyaXB0Q29tcGlsZXIoKTtcbiAgICAgICAgbGV0IGVyck1zZyA9ICdUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGZhaWxlZC5cXG4nO1xuXG4gICAgICAgIGRpYWdub3N0aWNzLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdHMuZmxhdHRlbkRpYWdub3N0aWNNZXNzYWdlVGV4dChkLm1lc3NhZ2VUZXh0LCAnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBmaWxlICAgID0gZC5maWxlO1xuXG4gICAgICAgICAgICBpZiAoZmlsZSAmJiBkLnN0YXJ0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxpbmUsIGNoYXJhY3RlciB9ID0gZmlsZS5nZXRMaW5lQW5kQ2hhcmFjdGVyT2ZQb3NpdGlvbihkLnN0YXJ0KTtcblxuICAgICAgICAgICAgICAgIGVyck1zZyArPSBgJHtmaWxlLmZpbGVOYW1lfSAoJHtsaW5lICsgMX0sICR7Y2hhcmFjdGVyICsgMX0pOiBgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJNc2cgKz0gYCR7bWVzc2FnZX1cXG5gO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgX2NvbXBpbGVDb2RlRm9yVGVzdEZpbGVzICh0ZXN0RmlsZXNJbmZvOiBUZXN0RmlsZUluZm9bXSk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RzQ29uZmlnLmluaXQodGhpcy5fY3VzdG9tQ29tcGlsZXJPcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5fY29tcGlsZUNvZGVGb3JUZXN0RmlsZXModGVzdEZpbGVzSW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jb21waWxlRmlsZXNUb0NhY2hlICh0czogVHlwZVNjcmlwdEluc3RhbmNlLCBmaWxlbmFtZXM6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG9wdHMgICAgPSB0aGlzLl90c0NvbmZpZy5nZXRPcHRpb25zKCkgYXMgRGljdGlvbmFyeTxDb21waWxlck9wdGlvbnNWYWx1ZT47XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB0cy5jcmVhdGVQcm9ncmFtKFtUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci50c0RlZnNQYXRoLCAuLi5maWxlbmFtZXNdLCBvcHRzKTtcblxuICAgICAgICBERUJVR19MT0dHRVIoJ3ZlcnNpb246ICVzJywgdHMudmVyc2lvbik7XG4gICAgICAgIERFQlVHX0xPR0dFUignb3B0aW9uczogJU8nLCBvcHRzKTtcblxuICAgICAgICBwcm9ncmFtLmdldFNvdXJjZUZpbGVzKCkuZm9yRWFjaChzb3VyY2VGaWxlID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgQSBoYWNrIHRvIGFsbG93IGltcG9ydCBnbG9iYWxseSBpbnN0YWxsZWQgVGVzdENhZmUgaW4gdGVzdHNcbiAgICAgICAgICAgIHNvdXJjZUZpbGUucmVuYW1lZERlcGVuZGVuY2llcyA9IFJFTkFNRURfREVQRU5ERU5DSUVTX01BUDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZGlhZ25vc3RpY3MgPSB0cy5nZXRQcmVFbWl0RGlhZ25vc3RpY3MocHJvZ3JhbSk7XG5cbiAgICAgICAgaWYgKGRpYWdub3N0aWNzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9ycyhkaWFnbm9zdGljcyk7XG5cbiAgICAgICAgLy8gTk9URTogVGhlIGZpcnN0IGFyZ3VtZW50IG9mIGVtaXQoKSBpcyBhIHNvdXJjZSBmaWxlIHRvIGJlIGNvbXBpbGVkLiBJZiBpdCdzIHVuZGVmaW5lZCwgYWxsIGZpbGVzIGluXG4gICAgICAgIC8vIDxwcm9ncmFtPiB3aWxsIGJlIGNvbXBpbGVkLiA8cHJvZ3JhbT4gY29udGFpbnMgYSBmaWxlIHNwZWNpZmllZCBpbiBjcmVhdGVQcm9ncmFtKCkgcGx1cyBhbGwgaXRzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgLy8gVGhpcyBtb2RlIGlzIG11Y2ggZmFzdGVyIHRoYW4gY29tcGlsaW5nIGZpbGVzIG9uZS1ieS1vbmUsIGFuZCBpdCBpcyB1c2VkIGluIHRoZSB0c2MgQ0xJIGNvbXBpbGVyLlxuICAgICAgICBwcm9ncmFtLmVtaXQodm9pZCAwLCAob3V0cHV0TmFtZSwgcmVzdWx0LCB3cml0ZUJPTSwgb25FcnJvciwgc291cmNlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2VzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3Qgc291cmNlUGF0aCA9IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9ub3JtYWxpemVGaWxlbmFtZShzb3VyY2VzWzBdLmZpbGVOYW1lKTtcblxuICAgICAgICAgICAgdGhpcy5jYWNoZVtzb3VyY2VQYXRoXSA9IHJlc3VsdDtcbiAgICAgICAgfSwgdm9pZCAwLCB2b2lkIDAsIHtcbiAgICAgICAgICAgIGJlZm9yZTogdGhpcy5fZ2V0VHlwZXNjcmlwdFRyYW5zZm9ybWVycygpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXRUeXBlc2NyaXB0VHJhbnNmb3JtZXJzICgpOiBUcmFuc2Zvcm1lckZhY3Rvcnk8U291cmNlRmlsZT5bXSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyczogVHJhbnNmb3JtZXJGYWN0b3J5PFNvdXJjZUZpbGU+W10gPSBbdGVzdGNhZmVJbXBvcnRQYXRoUmVwbGFjZXIoKV07XG5cbiAgICAgICAgaWYgKHRoaXMuaXNDb21waWxlclNlcnZpY2VNb2RlKVxuICAgICAgICAgICAgdHJhbnNmb3JtZXJzLnB1c2goZGlzYWJsZVY4T3B0aW1pemF0aW9uQ29kZUFwcGVuZGVyKCkpO1xuXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcnM7XG4gICAgfVxuXG4gICAgcHVibGljIF9wcmVjb21waWxlQ29kZSAodGVzdEZpbGVzSW5mbzogVGVzdEZpbGVJbmZvW10pOiBzdHJpbmdbXSB7XG4gICAgICAgIERFQlVHX0xPR0dFUigncGF0aDogXCIlc1wiJywgdGhpcy5fY29tcGlsZXJQYXRoKTtcblxuICAgICAgICAvLyBOT1RFOiBsYXp5IGxvYWQgdGhlIGNvbXBpbGVyXG4gICAgICAgIGNvbnN0IHRzOiBUeXBlU2NyaXB0SW5zdGFuY2UgPSB0aGlzLl9sb2FkVHlwZVNjcmlwdENvbXBpbGVyKCk7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lcyAgICAgICAgICAgICAgPSB0ZXN0RmlsZXNJbmZvLm1hcCgoeyBmaWxlbmFtZSB9KSA9PiBmaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaWxlbmFtZXMgICAgPSBmaWxlbmFtZXMubWFwKGZpbGVuYW1lID0+IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9ub3JtYWxpemVGaWxlbmFtZShmaWxlbmFtZSkpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRmlsZW5hbWVzTWFwID0gemlwT2JqZWN0KG5vcm1hbGl6ZWRGaWxlbmFtZXMsIGZpbGVuYW1lcyk7XG5cbiAgICAgICAgY29uc3QgdW5jYWNoZWRGaWxlcyA9IG5vcm1hbGl6ZWRGaWxlbmFtZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZmlsZW5hbWUgPT4gZmlsZW5hbWUgIT09IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLnRzRGVmc1BhdGggJiYgIXRoaXMuY2FjaGVbZmlsZW5hbWVdKVxuICAgICAgICAgICAgLm1hcChmaWxlbmFtZSA9PiBub3JtYWxpemVkRmlsZW5hbWVzTWFwW2ZpbGVuYW1lXSk7XG5cbiAgICAgICAgaWYgKHVuY2FjaGVkRmlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZUZpbGVzVG9DYWNoZSh0cywgdW5jYWNoZWRGaWxlcyk7XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlbmFtZXMubWFwKGZpbGVuYW1lID0+IHRoaXMuY2FjaGVbZmlsZW5hbWVdKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgX2dldFJlcXVpcmVDb21waWxlcnMgKCk6IFJlcXVpcmVDb21waWxlcnMge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJy50cyc6ICAoY29kZSwgZmlsZW5hbWUpID0+IHRoaXMuX2NvbXBpbGVDb2RlKGNvZGUsIGZpbGVuYW1lKSxcbiAgICAgICAgICAgICcudHN4JzogKGNvZGUsIGZpbGVuYW1lKSA9PiB0aGlzLl9jb21waWxlQ29kZShjb2RlLCBmaWxlbmFtZSksXG4gICAgICAgICAgICAnLmpzJzogIChjb2RlLCBmaWxlbmFtZSkgPT4gRVNOZXh0VGVzdEZpbGVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb2RlLmNhbGwodGhpcywgY29kZSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgJy5qc3gnOiAoY29kZSwgZmlsZW5hbWUpID0+IEVTTmV4dFRlc3RGaWxlQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlQ29kZS5jYWxsKHRoaXMsIGNvZGUsIGZpbGVuYW1lKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGNhblByZWNvbXBpbGUgKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0U3VwcG9ydGVkRXh0ZW5zaW9uICgpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiBbJy50cycsICcudHN4J107XG4gICAgfVxufVxuIl19